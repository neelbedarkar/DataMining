import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import multivariate_normal

data = np.array([[1.5, 4.5],
                 [2.2, 1.5],
                 [3.9, 3.4],
                 [2.1, 2.9],
                 [0.5, 3.2],
                 [0.9, 4.3],
                 [2.7, 2.1],
                 [2.5, 3.5],
                 [2.8, 4.9],
                 [0.1, 3.7]])
k = 3
# Initialization
u1 = np.array([0.5, 4.2])
u2 = np.array([2.4, 1.6])
u3 = np.array([3, 3.2])
means = np.array([u1, u2, u3])
print("initial means")
print(means)
cov_1 = cov_2 = cov_3 = np.array([[1, 0], [0, 1]])
cov = np.array([cov_1, cov_2, cov_3])
cov_li = [cov_1, cov_2, cov_3]
pc1 = pc2 = pc3 = 1 / 3
priors = [pc1, pc2, pc3]

# plotting initial mean and data
data_x, data_y = data.T
mean_x, mean_y = means.T

plt.scatter(data_x, data_y)

for i in range(0, len(data_x)):
    if i > 1:
        plt.annotate("x{}".format(i+1, data_x[i], data_y[i]), (data_x[i], data_y[i]), textcoords="offset points",
                     xytext=(-20, 10))
    else:
        plt.annotate("x{}".format(i+1, data_x[i], data_y[i]), (data_x[i], data_y[i]), textcoords="offset points",
                     xytext=(-30, 10))

markers = ["s", "<", "o"]

for i in range(3):
    mi = markers[i]  # marker for ith feature
    xi = mean_x[i]  # x array for ith feature
    yi = mean_y[i]  # y array for ith feature
    plt.scatter(xi, yi, marker=mi, color="r")

plt.annotate("Initial Mean 1 ({}, {}) ".format(mean_x[0], mean_y[0]),
             [mean_x[0], mean_y[0]], textcoords="offset points", xytext=(-40, 10))
plt.annotate("Initial Mean 2 ({}, {}) ".format(mean_x[1], mean_y[1]),
             [mean_x[1], mean_y[1]], textcoords="offset points", xytext=(0, 10))
plt.annotate("Initial Mean 3 ({}, {}) ".format(mean_x[2], mean_y[2]),
             [mean_x[2], mean_y[2]], textcoords="offset points", xytext=(0, 10))

# Expectation
pdf_normal_combined = []  # 3 by 10 matrix for pdf of each point for each cluster
for i in range(k):
    pdf_normal_combined.append(multivariate_normal.pdf(x=data, mean=means[i], cov=cov[i]))
pdf_normal_combined = np.array(pdf_normal_combined)

# Maximization
posterior_weights = [[0] * 10 for i in range(3)]
for i in range(k):
    # use the current values for the parameters to evaluate the posterior
    # probabilities of the data to have been generated by each gaussian
    for j in range(len(data)):
        num = pdf_normal_combined[i][j] * priors[i]
        denom = 0
        for a in range(k):
            denom += pdf_normal_combined[a][j] * priors[a]
        posterior_weights[i][j] = num / denom
posterior_weights = np.array(posterior_weights)

for i in range(k):
    num = np.array([0,0])
    denom = 0
    for j in range(len(data)):
        num = num + np.dot(posterior_weights[i][j], data[j])
        denom = denom + posterior_weights[i][j]
    means[i] = num/denom


for i in range(k):
    num = np.array([[0,0],[0,0]])
    denom = 0
    for j in range(len(data)):
        num = num + np.dot(posterior_weights[i][j], np.dot(np.matrix(data[j] - means[i]).T, np.matrix(data[j] - means[i])))
        denom = denom + posterior_weights[i][j]
    cov_li[i] = num/denom


for i in range(k):
    num = 0
    for j in range(len(data)):
        num = num + posterior_weights[i][j]
    priors[i] = num/10

# plot means and original data
print("means from manual EM iter 1:")
print(means)
mean_x, mean_y = means.T
for i in range(3):
    mi = markers[i]  # marker for ith feature
    xi = mean_x[i]  # x array for ith feature .. here is where you would generalize      different x for every feature
    yi = mean_y[i]  # y array for ith feature
    plt.scatter(xi, yi, marker=mi, color="g")

plt.annotate("Updated Mean 1 ({:.2f}, {:.2f}) ".format(mean_x[0], mean_y[0]),
             [mean_x[0], mean_y[0]], textcoords="offset points", xytext=(-40, 10))
plt.annotate("Updated Mean 2 ({:.2f}, {:.2f}) ".format(mean_x[1], mean_y[1]),
             [mean_x[1], mean_y[1]], textcoords="offset points", xytext=(0, 10))
plt.annotate("Updated Mean 3 ({:.2f}, {:.2f}) ".format(mean_x[2], mean_y[2]),
             [mean_x[2], mean_y[2]], textcoords="offset points", xytext=(0, 10))

print("Covariances from manual EM:")
for cov in cov_li:
    print(cov)
print("Priors from manual EM:")
print(priors)

# Direct use of scikit learn to implement EM
plt.show()

